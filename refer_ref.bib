@inproceedings{accelerateVMinterpreter,
    title      = {Short-{{Circuit Dispatch}}: {{Accelerating Virtual Machine Interpreters}} on {{Embedded Processors}}},
    shorttitle = {Short-{{Circuit Dispatch}}},
    booktitle  = {2016 {{ACM}}/{{IEEE}} 43rd {{Annual International Symposium}} on {{Computer Architecture}} ({{ISCA}})},
    author     = {Kim, Channoh and Kim, Sungmin and Cho, Hyeon Gyu and Kim, Dooyoung and Kim, Jaehyeok and Oh, Young H. and Jang, Hakbeom and Lee, Jae W.},
    year       = {2016},
    month      = jun,
    pages      = {291--303},
    publisher  = {IEEE},
    address    = {Seoul, South Korea},
    doi        = {10.1109/ISCA.2016.34},
    urldate    = {2025-01-02},
    isbn       = {978-1-4673-8947-1},
    langid     = {english}
}

@misc{aFasterWasmInterpreter,
    title         = {A Fast In-Place Interpreter for {{WebAssembly}}},
    author        = {Titzer, Ben L.},
    year          = {2022},
    month         = may,
    number        = {arXiv:2205.01183},
    eprint        = {2205.01183},
    publisher     = {arXiv},
    doi           = {10.48550/arXiv.2205.01183},
    urldate       = {2024-12-11},
    archiveprefix = {arXiv},
    langid        = {english}
}

@inproceedings{bachImpactCoverageBug2017,
    title     = {The {{Impact}} of {{Coverage}} on {{Bug Density}} in a {{Large Industrial Software Project}}},
    booktitle = {2017 {{ACM}}/{{IEEE International Symposium}} on {{Empirical Software Engineering}} and {{Measurement}} ({{ESEM}})},
    author    = {Bach, Thomas and Andrzejak, Artur and Pannemans, Ralf and Lo, David},
    year      = {2017},
    month     = nov,
    pages     = {307--313},
    publisher = {IEEE},
    address   = {Toronto, ON},
    doi       = {10.1109/ESEM.2017.44},
    url       = {  https://doi.org/10.1109/ESEM.2017.44
                 },
    urldate   = {2025-01-06},
    abstract  = {Measuring quality of test suites is one of the major challenges of software testing. Code coverage identifies tested and untested parts of code and is frequently used to approximate test suite quality. Multiple previous studies have investigated the relationship between coverage ratio and test suite quality, without a clear consent in the results. In this work we study whether covered code contains a smaller number of future bugs than uncovered code (assuming appropriate scaling). If this correlation holds and bug density is lower in covered code, coverage can be regarded as a meaningful metric to estimate the adequacy of testing. To this end we analyse 16 000 internal bug reports and bug-fixes of SAP HANA, a large industrial software project. We found that the above-mentioned relationship indeed holds, and is statistically significant. Contrary to most previous works our study uses real bugs and real bug-fixes. Furthermore, our data is derived from a complex and large industrial project.},
    isbn      = {978-1-5090-4039-1},
    langid    = {english},
    file      = {F:\Zotero\Data-storage\storage\J7PQT3EJ\Bach 等 - 2017 - The Impact of Coverage on Bug Density in a Large Industrial Software Project.pdf}
}
@inproceedings{bhansaliFirstLookCode2022,
    title     = {A {{First Look}} at {{Code Obfuscation}} for {{WebAssembly}}},
    booktitle = {Proceedings of the 15th {{ACM Conference}} on {{Security}} and {{Privacy}} in {{Wireless}} and {{Mobile Networks}}},
    author    = {Bhansali, Shrenik and Aris, Ahmet and Acar, Abbas and Oz, Harun and Uluagac, A. Selcuk},
    year      = {2022},
    month     = may,
    pages     = {140--145},
    publisher = {ACM},
    address   = {San Antonio TX USA},
    doi       = {10.1145/3507657.3528560},
    url       = {https://doi.org/10.1145/3507657.3528560},
    urldate   = {2024-11-28},
    isbn      = {978-1-4503-9216-7},
    langid    = {english}
}
@inproceedings{bhuiyanSecBenchjsExecutableSecurity2023,
    title      = {{{SecBench}}.Js: {{An Executable Security Benchmark Suite}} for {{Server-Side JavaScript}}},
    shorttitle = {{{SecBench}}.Js},
    booktitle  = {2023 {{IEEE}}/{{ACM}} 45th {{International Conference}} on {{Software Engineering}} ({{ICSE}})},
    author     = {Bhuiyan, Masudul Hasan Masud and Parthasarathy, Adithya Srinivas and Vasilakis, Nikos and Pradel, Michael and Staicu, Cristian-Alexandru},
    year       = {2023},
    month      = may,
    pages      = {1059--1070},
    publisher  = {IEEE},
    address    = {Melbourne, Australia},
    doi        = {10.1109/ICSE48619.2023.00096},
    urldate    = {2025-01-06},
    abstract   = {Npm is the largest software ecosystem in the world, offering millions of free, reusable packages. In recent years, various security threats to packages published on npm have been reported, including vulnerabilities that affect millions of users. To continuously improve techniques for detecting vulnerabilities and mitigating attacks that exploit them, a reusable benchmark of vulnerabilities would be highly desirable. Ideally, such a benchmark should be realistic, come with executable exploits, and include fixes of vulnerabilities. Unfortunately, there currently is no such benchmark, forcing researchers to repeatedly develop their own evaluation datasets and making it difficult to compare techniques with each other. This paper presents SECBENCH.JS, the first comprehensive benchmark suite of vulnerabilities and executable exploits for npm. The benchmark comprises 600 vulnerabilities, which cover the five most common vulnerability classes for server-side JavaScript. Each vulnerability comes with a payload that exploits the vulnerability and an oracle that validates successful exploitation. SECBENCH.JS enables various applications, of which we explore three in this paper: (i) crosschecking SECBENCH.JS against public security advisories reveals 168 vulnerable versions in 19 packages that are mislabeled in the advisories; (ii) applying simple code transformations to the exploits in our suite helps identify flawed fixes of vulnerabilities; (iii) dynamically analyzing calls to common sink APIs, e.g., exec(), yields a ground truth of code locations for evaluating vulnerability detectors. Beyond providing a reusable benchmark to the community, our work identified 20 zero-day vulnerabilities, most of which are already acknowledged by practitioners.},
    copyright  = {https://doi.org/10.15223/policy-029},
    isbn       = {978-1-6654-5701-9},
    langid     = {english},
    file       = {F:\Zotero\Data-storage\storage\EQ68FQZE\Bhuiyan 等 - 2023 - SecBench.js An Executable Security Benchmark Suite for Server-Side JavaScript.pdf}
}

@techreport{BytecodeJiuJitsuChoking,
    type        = {{{PPT}}},
    title       = {Bytecode {{Jiu-Jitsu}}  {{Choking Interpreters}} to {{Force Execution}} of {{Malicious Bytecode}}},
    author      = {Usui, Toshinori and Otsuki, Yuto},
    year        = {2024},
    address     = {United States of America},
    institution = {Black Hat},
    langid      = {english}
}
@misc{caoWASMixerBinaryObfuscation2023,
    title         = {{{WASMixer}}: {{Binary Obfuscation}} for {{WebAssembly}}},
    shorttitle    = {{{WASMixer}}},
    author        = {Cao, Shangtong and He, Ningyu and Guo, Yao and Wang, Haoyu},
    year          = {2023},
    month         = aug,
    number        = {arXiv:2308.03123},
    eprint        = {2308.03123},
    publisher     = {arXiv},
    doi           = {10.48550/arXiv.2308.03123},
    url           = {https://doi.org/10.48550/arXiv.2308.03123},
    urldate       = {2024-12-11},
    archiveprefix = {arXiv}
}
@article{celikDesignImplementationApplication2019,
    title    = {Design, Implementation, and Application of {{GPU-based Java}} Bytecode Interpreters},
    author   = {Celik, Ahmet and Nie, Pengyu and Rossbach, Christopher J. and Gligoric, Milos},
    year     = {2019},
    month    = oct,
    journal  = {Proceedings of the ACM on Programming Languages},
    volume   = {3},
    number   = {OOPSLA},
    pages    = {1--28},
    issn     = {2475-1421},
    doi      = {10.1145/3360603},
    urldate  = {2025-01-02},
    abstract = {AHMET CELIK, The University of Texas at Austin, USA PENGYU NIE, The University of Texas at Austin, USA CHRISTOPHER J. ROSSBACH, The University of Texas at Austin and VMware Research, USA MILOS GLIGORIC, The University of Texas at Austin, USA We present the design and implementation of GVM, the first system for executing Java bytecode entirely on GPUs. GVM is ideal for applications that execute a large number of short-living tasks, which share a significant fraction of their codebase and have similar execution time. GVM uses novel algorithms, scheduling, and data layout techniques to adapt to the massively parallel programming and execution model of GPUs. We apply GVM to generate and execute tests for Java projects. First, we implement a sequence-based test generation on top of GVM and design novel algorithms to avoid redundant test sequences. Second, we use GVM to execute randomly generated test cases. We evaluate GVM by comparing it with two existing Java bytecode interpreters (Oracle JVM and Java Pathfinder), as well as with the Oracle JVM with just-in-time (JIT) compiler, which has been engineered and optimized for over twenty years. Our evaluation shows that sequence-based test generation on GVM outperforms both Java Pathfinder and Oracle JVM interpreter. Additionally, our results show that GVM performs as well as running our parallel sequence-based test generation algorithm using JVM with JIT with many CPU threads. Furthermore, our evaluation on several classes from open-source projects shows that executing randomly generated tests on GVM outperforms sequential execution on JVM interpreter and JVM with JIT. CCS Concepts: {$\bullet$} Software and its engineering {$\rightarrow$} Object oriented languages; Interpreters; Runtime environments; Software testing and debugging.},
    langid   = {english},
    file     = {F:\Zotero\Data-storage\storage\MQ4YFI4Q\Celik 等 - 2019 - Design, implementation, and application of GPU-based Java bytecode interpreters.pdf}
}
@misc{ChakraCore,
    author       = {Microsoft},
    howpublished = {\url{https://github.com/chakra-core/ChakraCore}},
    title        = {ChakraCore},
    year         = {2024}
}
@article{chaliasosWelltypedProgramsCan2021,
    title      = {Well-Typed Programs Can Go Wrong: A Study of Typing-Related Bugs in {{JVM}} Compilers},
    shorttitle = {Well-Typed Programs Can Go Wrong},
    author     = {Chaliasos, Stefanos and Sotiropoulos, Thodoris and Drosos, Georgios-Petros and Mitropoulos, Charalambos and Mitropoulos, Dimitris and Spinellis, Diomidis},
    year       = {2021},
    month      = oct,
    journal    = {Proceedings of the ACM on Programming Languages},
    volume     = {5},
    number     = {OOPSLA},
    pages      = {1--30},
    issn       = {2475-1421},
    doi        = {10.1145/3485500},
    urldate    = {2025-01-04},
    langid     = {english}
}
@inproceedings{CpythonIsWrittenInC,
    title     = {Triangulating Python Performance Issues with {{SCALENE}}},
    booktitle = {17th {{USENIX}} Symposium on Operating Systems Design and Implementation ({{OSDI}} 23)},
    author    = {Berger, Emery D. and Stern, Sam and Pizzorno, Juan Altmayer},
    year      = {2023},
    month     = jul,
    pages     = {51--64},
    publisher = {USENIX Association},
    address   = {Boston, MA},
    isbn      = {978-1-939133-34-2},
    file      = {F:\Zotero\Data-storage\storage\CQ6QYLWL\Berger 等 - Triangulating Python Performance Issues with Scalene.pdf}
}
@book{CraftingInterpreters,
    title     = {Crafting Interpreters},
    author    = {Nystrom, Robert},
    year      = {2021},
    publisher = {Verlag nicht ermittelbar},
    address   = {Erscheinungsort nicht ermittelbar},
    isbn      = {978-0-9905829-3-9},
    langid    = {english}
}
@inproceedings{CVC5,
    author    = {Barbosa, Haniel
                 and Barrett, Clark
                 and Brain, Martin
                 and Kremer, Gereon
                 and Lachnitt, Hanna
                 and Mann, Makai
                 and Mohamed, Abdalrhman
                 and Mohamed, Mudathir
                 and Niemetz, Aina
                 and N{\"o}tzli, Andres
                 and Ozdemir, Alex
                 and Preiner, Mathias
                 and Reynolds, Andrew
                 and Sheng, Ying
                 and Tinelli, Cesare
                 and Zohar, Yoni},
    editor    = {Fisman, Dana
                 and Rosu, Grigore},
    title     = {cvc5: A Versatile and Industrial-Strength SMT Solver},
    booktitle = {Tools and Algorithms for the Construction and Analysis of Systems},
    year      = {2022},
    publisher = {Springer International Publishing},
    address   = {Cham},
    pages     = {415--442},
    isbn      = {978-3-030-99524-9}
}
@inproceedings{Daniel2019DiscoveringVI,
    title  = {Discovering Vulnerabilities in {{WebAssembly}} with Code Property Graphs},
    author = {Daniel, Pedro and Lopes, Rogeiro and Santos, Nuno and Santos, Jos{\textasciiacute}e Fragoso},
    year   = {2019},
    file   = {F:\Zotero\Data-storage\storage\9AH4UIBZ\Lopes - Discovering Vulnerabilities in WebAssembly with Code Property Graphs.pdf}
}
@misc{DragonWell,
    author       = {Alibaba},
    howpublished = {\url{https://github.com/dragonwell-project/dragonwell11}},
    title        = {DragonWell},
    year         = {2025}
}
@incollection{dxoHevmFastSymbolic2024,
    title     = {Hevm, a {{Fast Symbolic Execution Framework}} for {{EVM Bytecode}}},
    booktitle = {Computer {{Aided Verification}}},
    author    = {{Dxo} and Soos, Mate and Paraskevopoulou, Zoe and Lundfall, Martin and Brockman, Mikael},
    editor    = {Gurfinkel, Arie and Ganesh, Vijay},
    year      = {2024},
    volume    = {14681},
    pages     = {453--465},
    publisher = {Springer Nature Switzerland},
    address   = {Cham},
    doi       = {10.1007/978-3-031-65627-9_22},
    urldate   = {2025-01-06},
    abstract  = {We present hevm, a symbolic execution engine for the EVM. hevm can prove safety properties for EVM bytecode or verify semantic equivalence between two bytecode objects. It exposes a user-friendly API in Solidity that allows end-users to define symbolic tests using almost the same syntax as they would for their usual unit tests. We evaluate our framework against state-of-the-art tools, using a comprehensive set of benchmarks. Our empirical findings demonstrate that hevm outperforms its counterparts, effectively solving a greater number of problems within competitive time frames.},
    isbn      = {978-3-031-65626-2},
    langid    = {english},
    file      = {F:\Zotero\Data-storage\storage\8KPYGA7P\Dxo 等 - 2024 - Hevm, a Fast Symbolic Execution Framework for EVM Bytecode.pdf}
}
@inproceedings{EffectiveFuzzWebAPP4PHP,
    title     = {Atropos: {{Effective}} Fuzzing of Web Applications for {{Server-Side}} Vulnerabilities},
    booktitle = {33rd {{USENIX}} Security Symposium ({{USENIX}} Security 24)},
    author    = {G{\"u}ler, Emre and Schumilo, Sergej and Schloegel, Moritz and Bars, Nils and G{\"o}rz, Philipp and Xu, Xinyi and Kaygusuz, Cemal and Holz, Thorsten},
    year      = {2024},
    month     = aug,
    pages     = {4765--4782},
    publisher = {USENIX Association},
    address   = {Philadelphia, PA},
    isbn      = {978-1-939133-44-1},
    file      = {F:\Zotero\Data-storage\storage\4MII9464\Güler 等 - Atropos Effective Fuzzing of Web Applications for Server-Side Vulnerabilities.pdf}
}

@inproceedings{eomFuzzingJavaScriptInterpreters2024,
    title     = {Fuzzing {{JavaScript Interpreters}} with {{Coverage-Guided Reinforcement Learning}} for {{LLM-Based Mutation}}},
    booktitle = {Proceedings of the 33rd {{ACM SIGSOFT International Symposium}} on {{Software Testing}} and {{Analysis}}},
    author    = {Eom, Jueon and Jeong, Seyeon and Kwon, Taekyoung},
    year      = {2024},
    month     = sep,
    pages     = {1656--1668},
    publisher = {ACM},
    address   = {Vienna Austria},
    doi       = {10.1145/3650212.3680389},
    urldate   = {2024-12-31},
    abstract  = {JavaScript interpreters, crucial for modern web browsers, require an effective fuzzing method to identify security-related bugs. However, the strict grammatical requirements for input present significant challenges. Recent efforts to integrate language models for contextaware mutation in fuzzing are promising but lack the necessary coverage guidance to be fully effective. This paper presents a novel technique called CovRL (Coverage-guided Reinforcement Learning) that combines Large Language Models (LLMs) with Reinforcement Learning (RL) from coverage feedback. Our fuzzer, CovRL-Fuzz, integrates coverage feedback directly into the LLM by leveraging the Term Frequency-Inverse Document Frequency (TF-IDF) method to construct a weighted coverage map. This map is key in calculating the fuzzing reward, which is then applied to the LLM-based mutator through reinforcement learning. CovRL-Fuzz, through this approach, enables the generation of test cases that are more likely to discover new coverage areas, thus improving bug detection while minimizing syntax and semantic errors, all without needing extra post-processing. Our evaluation results show that CovRL-Fuzz outperforms the state-of-the-art fuzzers in enhancing code coverage and identifying bugs in JavaScript interpreters: CovRL-Fuzz identified 58 real-world security-related bugs in the latest JavaScript interpreters, including 50 previously unknown bugs and 15 CVEs.},
    isbn      = {979-8-4007-0612-7},
    langid    = {english},
    file      = {F:\Zotero\Data-storage\storage\8WPKGPS8\Eom 等 - 2024 - Fuzzing JavaScript Interpreters with Coverage-Guided Reinforcement Learning for LLM-Based Mutation.pdf}
}

@article{ExampleOnevmInterpreter,
    title    = {A Bytecode-based Integrated Detection and Repair Method for Reentrancy Vulnerabilities in Smart Contracts},
    author   = {Feng, Zijun and Feng, Yuming and He, Hui and Zhang, Weizhe and Zhang, Yu},
    year     = {2024},
    month    = sep,
    journal  = {IET Blockchain},
    volume   = {4},
    number   = {3},
    pages    = {235--251},
    issn     = {2634-1573, 2634-1573},
    doi      = {10.1049/blc2.12043},
    urldate  = {2025-01-02},
    abstract = {The reentrancy vulnerability in smart contracts has caused significant losses in the digital currency economy. Existing solutions for detecting and repairing this vulnerability are limited in scope and lack a comprehensive framework. Additionally, there is currently a lack of guidance methods for effectively pinpointing the location of vulnerabilities. The proposed bytecode-level method addresses these challenges by incorporating a detection module, an auxiliary localization module, and a repair module. An opcode classification method is introduced using vulnerability features and a BiLSTM-Attention-based sequence model to enhance detection accuracy. To overcome difficulties in vulnerability localization, an auxiliary localization method based on data flow and control flow analysis is proposed, enabling developers to better locate vulnerabilities. Current reentrancy vulnerability repair methods are analyzed and strategies for three reachable patterns are proposed. The bytecode rewriting strategy utilizes Trampoline technology for repair, while a fuel optimization method reduces bytecode generation length to optimize gas costs. Through extensive experimental validation, the effectiveness and superiority of the proposed methods are confirmed, further validating the feasibility of the entire framework. Experimental results demonstrate that the framework offers enhanced protection against reentrancy vulnerability attacks in smart contracts.},
    langid   = {english},
    file     = {F:\Zotero\Data-storage\storage\F23HMBZM\Feng 等 - 2024 - A bytecode‐based integrated detection and repair method for reentrancy vulnerabilities in smart cont.pdf}
}
@misc{fangPerformanceSurveyStackbased2016,
    title         = {A {{Performance Survey}} on {{Stack-based}} and {{Register-based Virtual Machines}}},
    author        = {Fang, Ruijie and Liu, Siqi},
    year          = {2016},
    month         = nov,
    number        = {arXiv:1611.00467},
    eprint        = {1611.00467},
    primaryclass  = {cs},
    publisher     = {arXiv},
    doi           = {10.48550/arXiv.1611.00467},
    urldate       = {2025-01-05},
    abstract      = {Virtual machines have been widely adapted for high-level programming language implementations and for providing a degree of platform neutrality. As the overall use and adaptation of virtual machines grow, the overall performance of virtual machines has become a widely-discussed topic. In this paper, we present a survey on the performance differences of the two most widely adapted types of virtual machines - the stack-based virtual machine and the register-based virtual machine - using various benchmark programs. Additionally, we adopted a new approach of measuring performance by measuring the overall dispatch time, amount of dispatches, fetch time, and execution time while running benchmarks on custom-implemented, lightweight virtual machines. Finally, we present two lightweight, custom-designed, Turing-equivalent virtual machines that are specifically designed in benchmarking virtual machine performance - the ``Conceptum'' stack-based virtual machine, and the ``Inertia'' register-based virtual machine. Our result showed that while on average the register machine spends 20.39\% less time in executing benchmarks than the stack machine, the stack-based virtual machine is still faster than the virtual machine regarding the instruction fetch time.},
    archiveprefix = {arXiv},
    langid        = {english},
    keywords      = {Computer Science - Programming Languages},
    file          = {F:\Zotero\Data-storage\storage\HZBD3IMY\Fang和Liu - 2016 - A Performance Survey on Stack-based and Register-based Virtual Machines.pdf}
}

@article{fengBytecodebasedIntegratedDetection2024,
    title    = {A Bytecode-based Integrated Detection and Repair Method for Reentrancy Vulnerabilities in Smart Contracts},
    author   = {Feng, Zijun and Feng, Yuming and He, Hui and Zhang, Weizhe and Zhang, Yu},
    year     = {2024},
    month    = sep,
    journal  = {IET Blockchain},
    volume   = {4},
    number   = {3},
    pages    = {235--251},
    issn     = {2634-1573, 2634-1573},
    doi      = {10.1049/blc2.12043},
    urldate  = {2025-01-02},
    abstract = {The reentrancy vulnerability in smart contracts has caused significant losses in the digital currency economy. Existing solutions for detecting and repairing this vulnerability are limited in scope and lack a comprehensive framework. Additionally, there is currently a lack of guidance methods for effectively pinpointing the location of vulnerabilities. The proposed bytecode-level method addresses these challenges by incorporating a detection module, an auxiliary localization module, and a repair module. An opcode classification method is introduced using vulnerability features and a BiLSTM-Attention-based sequence model to enhance detection accuracy. To overcome difficulties in vulnerability localization, an auxiliary localization method based on data flow and control flow analysis is proposed, enabling developers to better locate vulnerabilities. Current reentrancy vulnerability repair methods are analyzed and strategies for three reachable patterns are proposed. The bytecode rewriting strategy utilizes Trampoline technology for repair, while a fuel optimization method reduces bytecode generation length to optimize gas costs. Through extensive experimental validation, the effectiveness and superiority of the proposed methods are confirmed, further validating the feasibility of the entire framework. Experimental results demonstrate that the framework offers enhanced protection against reentrancy vulnerability attacks in smart contracts.},
    langid   = {english},
    file     = {F:\Zotero\Data-storage\storage\F23HMBZM\Feng 等 - 2024 - A bytecode‐based integrated detection and repair method for reentrancy vulnerabilities in smart cont.pdf}
}
@book{friedmanEssentialsProgrammingLanguages2008,
    title     = {Essentials of Programming Languages},
    author    = {Friedman, Daniel P. and Wand, Mitchell},
    year      = {2008},
    edition   = {3rd ed},
    publisher = {MIT Press},
    address   = {Cambridge, MA},
    isbn      = {978-0-262-06279-4},
    langid    = {english},
    lccn      = {QA76.7 .F73 2008},
    keywords  = {Programming languages (Electronic computers)},
    file      = {F:\Zotero\Data-storage\storage\W8S7ERIC\Friedman和Wand - 2008 - Essentials of programming languages.pdf}
}

@misc{FrontEndCompilerCheerp,
    author       = {{Leaning Technologies}},
    howpublished = {\url{https://leaningtech.com/cheerp/}},
    title        = {{An Enterprise-Grade C++ Compiler For The Web}},
    year         = {2024}
}
@misc{FrontEndCompileremscripten,
    author       = {{Emscripten Contributors}},
    howpublished = {\url{https://emscripten.org/}},
    title        = {emscripten},
    year         = {2015}
}

@inproceedings{gershuniSimplePreciseStatic2019,
    title     = {Simple and Precise Static Analysis of Untrusted {{Linux}} Kernel Extensions},
    booktitle = {Proceedings of the 40th {{ACM SIGPLAN Conference}} on {{Programming Language Design}} and {{Implementation}}},
    author    = {Gershuni, Elazar and Amit, Nadav and Gurfinkel, Arie and Narodytska, Nina and Navas, Jorge A. and Rinetzky, Noam and Ryzhyk, Leonid and Sagiv, Mooly},
    year      = {2019},
    month     = jun,
    pages     = {1069--1084},
    publisher = {ACM},
    address   = {Phoenix AZ USA},
    doi       = {10.1145/3314221.3314590},
    urldate   = {2024-12-11},
    isbn      = {978-1-4503-6712-7},
    langid    = {english},
    file      = {F:\Zotero\Data-storage\storage\8M42WZN7\Gershuni 等 - 2019 - Simple and precise static analysis of untrusted Linux kernel extensions.pdf}
}

@misc{GoogleClusterFuzz,
    author       = {Google},
    howpublished = {\url{https://google.github.io/clusterfuzz/}},
    title        = {ClusterFuzz},
    year         = {2024}
}
@manual{groupWebAssemblySpecification2024,
    title  = {WebAssembly Specification},
    url    = {https://github.com/WebAssembly/spec/},
    author = {{{WebAssembly Community}} and {{Rossberg Andreas}}},
    year   = {2024}
}

@inproceedings{haasBringingWebSpeed2017,
    title     = {Bringing the Web up to Speed with {{WebAssembly}}},
    booktitle = {Proceedings of the 38th {{ACM SIGPLAN Conference}} on {{Programming Language Design}} and {{Implementation}}},
    author    = {Haas, Andreas and Rossberg, Andreas and Schuff, Derek L. and Titzer, Ben L. and Holman, Michael and Gohman, Dan and Wagner, Luke and Zakai, Alon and Bastien, Jf},
    year      = {2017},
    month     = jun,
    pages     = {185--200},
    publisher = {ACM},
    address   = {Barcelona Spain},
    doi       = {10.1145/3062341.3062363},
    urldate   = {2024-11-28},
    abstract  = {The maturation of the Web platform has given rise to sophisticated and demanding Web applications such as interactive 3D visualization, audio and video software, and games. With that, efficiency and security of code on the Web has become more important than ever. Yet JavaScript as the only builtin language of the Web is not well-equipped to meet these requirements, especially as a compilation target.},
    isbn      = {978-1-4503-4988-8},
    langid    = {english},
    file      = {F:\Zotero\Data-storage\storage\BE53QJLM\Haas 等 - 2017 - Bringing the web up to speed with WebAssembly.pdf}
}
@misc{Halmos,
    author = {Daejun Park},
    url    = {https://github.com/a16z/halmos},
    title  = {Halmos, a symbolic testing tool for EVM smart contracts},
    year   = {2024}
}

@mastersthesis{holtskogSecurityNodejsTheory2023,
    title   = {Security in {{Node}}.Js from {{Theory}} to {{Practice}}},
    author  = {Holtskog, Sindre},
    year    = {2023},
    address = {OSLO},
    langid  = {english},
    school  = {UNIVERSITY OF OSLO}
}

@misc{IBMOpenJ9,
    author       = {IBM},
    howpublished = {\url{https://eclipse.dev/openj9/}},
    title        = {Openj9},
    year         = {2024}
}
@manual{ierusalimschyLua54Reference2020,
    title  = {Lua 5.4 {{Reference Manual}}},
    author = {Ierusalimschy, Roberto and {Luiz Henrique de Figueiredo} and Celes, Waldemar },
    year   = {2020},
    url    = {https://www.lua.org/manual/5.4/}
}
@book{ierusalimschyProgrammingLua532016,
    title      = {{Programming in Lua: 5.3 edition}},
    shorttitle = {{Programming in Lua}},
    author     = {Ierusalimschy, Roberto},
    year       = {2016},
    month      = apr,
    publisher  = {Roberto Ierusalimschy},
    isbn       = {978-85-903798-6-7},
    langid     = {brazilian}
}
@manual{IntelDevelopManual,
    author = {Intel},
    title  = {Intel® 64 and IA-32 Architectures Software Developer's Manual Combined Volumes: 1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D, and 4},
    url    = {https://cdrdv2.intel.com/v1/dl/getContent/843820?fileName=325462-sdm-vol-1-2abcd-3abcd-4-1.pdf},
    year   = {2024}
}
@incollection{interpflow,
    title      = {Interp-Flow {{Hijacking}}: {{Launching Non-control Data Attack}} via {{Hijacking eBPF Interpretation Flow}}},
    shorttitle = {Interp-Flow {{Hijacking}}},
    booktitle  = {Computer {{Security}} -- {{ESORICS}} 2024},
    author     = {Liu, Qirui and Shen, Wenbo and Zhou, Jinmeng and Zhang, Zhuoruo and Hu, Jiayi and Ni, Shukai and Lu, Kangjie and Chang, Rui},
    editor     = {{Garcia-Alfaro}, Joaquin and Kozik, Rafa{\l} and Chora{\'s}, Micha{\l} and Katsikas, Sokratis},
    year       = {2024},
    volume     = {14984},
    pages      = {194--214},
    publisher  = {Springer Nature Switzerland},
    address    = {Cham},
    doi        = {10.1007/978-3-031-70896-1_10},
    urldate    = {2024-12-17},
    isbn       = {978-3-031-70895-4},
    langid     = {english},
    file       = {F:\Zotero\Data-storage\storage\NDVGCNWN\Liu 等 - 2024 - Interp-flow Hijacking Launching Non-control Data Attack via Hijacking eBPF Interpretation Flow.pdf}
}
@inproceedings{interpretizer,
    author    = {Klimiankou, Yauhen},
    editor    = {Mazzara, Manuel
                 and Bruel, Jean-Michel
                 and Meyer, Bertrand
                 and Petrenko, Alexander},
    title     = {Interpretizer: A Compiler-Independent Conversion of Switch-Based Dispatch into Threaded Code},
    booktitle = {Software Technology: Methods and Tools},
    year      = {2019},
    publisher = {Springer International Publishing},
    address   = {Cham},
    pages     = {59--72},
    isbn      = {978-3-030-29852-4}
}
@book{intro2Computing,
    title      = {Introduction to Computing: Explorations in Language, Logic, and Machines},
    shorttitle = {Introduction to Computing},
    author     = {Evans, David},
    year       = {2011},
    edition    = {Version: August 15, 2011},
    address    = {Lexington, Ky.},
    isbn       = {978-1-4636-8747-2},
    langid     = {english}
}
@inproceedings{jiaDetectingJVMJIT2023,
    title     = {Detecting {{JVM JIT Compiler Bugs}} via {{Exploring Two-Dimensional Input Spaces}}},
    booktitle = {2023 {{IEEE}}/{{ACM}} 45th {{International Conference}} on {{Software Engineering}} ({{ICSE}})},
    author    = {Jia, Haoxiang and Wen, Ming and Xie, Zifan and Guo, Xiaochen and Wu, Rongxin and Sun, Maolin and Chen, Kang and Jin, Hai},
    year      = {2023},
    month     = may,
    pages     = {43--55},
    publisher = {IEEE},
    address   = {Melbourne, Australia},
    doi       = {10.1109/ICSE48619.2023.00016},
    urldate   = {2024-12-31},
    copyright = {https://doi.org/10.15223/policy-029},
    isbn      = {978-1-6654-5701-9},
    langid    = {english},
    file      = {F:\Zotero\Data-storage\storage\WLWSPGB3\Jia 等 - 2023 - Detecting JVM JIT Compiler Bugs via Exploring Two-Dimensional Input Spaces.pdf}
}
@misc{jiangFuzzingPHPInterpreter2024,
    title         = {Fuzzing the {{PHP Interpreter}} via {{Dataflow Fusion}}},
    author        = {Jiang, Yuancheng and Zhang, Chuqi and Ruan, Bonan and Liu, Jiahao and Rigger, Manuel and Yap, Roland and Liang, Zhenkai},
    year          = {2024},
    month         = oct,
    number        = {arXiv:2410.21713},
    eprint        = {2410.21713},
    primaryclass  = {cs},
    publisher     = {arXiv},
    doi           = {10.48550/arXiv.2410.21713},
    urldate       = {2024-12-23},
    archiveprefix = {arXiv},
    langid        = {english}
}
@article{JSEngineBugs,
    title    = {An Empirical Study on Bugs in {{JavaScript}} Engines},
    author   = {Wang, Ziyuan and Bu, Dexin and Wang, Nannan and Yu, Sijie and Gou, Shanyi and Sun, Aiyue},
    year     = {2023},
    month    = mar,
    journal  = {Information and Software Technology},
    volume   = {155},
    pages    = {107105},
    issn     = {09505849},
    doi      = {10.1016/j.infsof.2022.107105},
    urldate  = {2025-01-03},
    abstract = {Objective: An in-depth understanding of the characteristics of bugs in JavaScript engines can help detect and fix them. Methods: We conduct an empirical study on the bugs in three mainstream JavaScript engines: V8, SpiderMonkey, and Chakra. Such an empirical study involves 19,019 bug reports, 16,437 revisions, 805 test cases, and root causes of randomly selected 540 bugs. Results: (1) The Compiler and the DOM are the most buggy component in V8 and SpiderMonkey, respectively. Most of the source files contain only one bug. (2) The scales of the testing programs that reveal bugs are usually small. Most bug fixes involve only limited modifications since the number of modified source files and lines of code modified are small. (3) Most bugs can be fixed within half a year (80.33\% for V8 and 91.9\% for SpiderMonkey). Only 4.33\% of SpiderMonkey bugs need more than a year to fix. Bugs in SpiderMonkey are usually fixed faster than bugs in V8. (4) High priority tends to be assigned to Infrastructure bugs in V8 and Release Automation bugs in SpiderMonkey. The duration of bugs is not strictly correlated with their priorities. (5) Semantic bugs are the most common root causes of bugs. And among semantic bugs, the processing bugs, missing features bugs and function call bugs are more than others. Conclusion: This study deepens our understanding of bugs in JavaScript engines, and empirical results could indicate some potential problems during the detecting and fixing of bugs in JavaScript engines, assist developers of JavaScript engines in improving their development quality, assist maintainers in detecting and fixing bugs more effectively, and suggest users of JavaScript evade potential risks.},
    langid   = {english},
    file     = {F:\Zotero\Data-storage\storage\F2XYGLWL\Wang 等 - 2023 - An empirical study on bugs in JavaScript engines.pdf}
}
@misc{JVMcrashReport,
    author       = {{Webbug Group}},
    howpublished = {\url{https://bugs.openjdk.org/browse/JDK-8290711}},
    title        = {{Assert(false) failed: infinite loop in PhaseIterGVN::optimize}},
    year         = {2022}
}
@inproceedings{KEVM,
    author    = {Hildenbrandt, Everett and Saxena, Manasvi and Rodrigues, Nishant and Zhu, Xiaoran and Daian, Philip and Guth, Dwight and Moore, Brandon and Park, Daejun and Zhang, Yi and Stefanescu, Andrei and Rosu, Grigore},
    booktitle = {2018 IEEE 31st Computer Security Foundations Symposium (CSF)},
    title     = {KEVM: A Complete Formal Semantics of the Ethereum Virtual Machine},
    year      = {2018},
    volume    = {},
    number    = {},
    pages     = {204-217},
    keywords  = {Contracts;Semantics;Tools;Virtual machining;Bitcoin;kevm;evm;ethereum;blockchain;k-framework;verification;smart-contract;semantics;ethereum-virtual-machine;formal-methods},
    doi       = {10.1109/CSF.2018.00022}
}
@inproceedings{kFoldCrossVerification,
    author    = {Le, Nhung
                 and M{\"a}nnel, Benjamin
                 and Jarema, Mihaela
                 and Luong, Thach Thanh
                 and Bui, Luyen K.
                 and Vy, Hai Quoc
                 and Schuh, Harald},
    editor    = {{\c{C}}iner, Attila
                 and Erg{\"u}ler, Zeynal Abiddin
                 and Bezzeghoud, Mourad
                 and Ustuner, Mustafa
                 and Eshagh, Mehdi
                 and El-Askary, Hesham
                 and Biswas, Arkoprovo
                 and Gasperini, Luca
                 and Hinzen, Klaus-G{\"u}nter
                 and Karakus, Murat
                 and Comina, Cesare
                 and Karrech, Ali
                 and Polonia, Alina
                 and Chamin{\'e}, Helder I.},
    title     = {K-Fold Cross-Validation: An Effective Hyperparameter Tuning Technique in Machine Learning on GNSS Time Series for Movement Forecast},
    booktitle = {Recent Research on Geotechnical Engineering, Remote Sensing, Geophysics and Earthquake Seismology},
    year      = {2024},
    publisher = {Springer Nature Switzerland},
    address   = {Cham},
    pages     = {377--382},
    isbn      = {978-3-031-43218-7}
}
@article{laroseASTVsBytecode2023,
    title      = {{{AST}} vs. {{Bytecode}}: {{Interpreters}} in the {{Age}} of {{Meta-Compilation}}},
    shorttitle = {{{AST}} vs. {{Bytecode}}},
    author     = {Larose, Octave and Kaleba, Sophie and Burchell, Humphrey and Marr, Stefan},
    year       = {2023},
    month      = oct,
    journal    = {Proceedings of the ACM on Programming Languages},
    volume     = {7},
    number     = {OOPSLA2},
    pages      = {318--346},
    issn       = {2475-1421},
    doi        = {10.1145/3622808},
    urldate    = {2025-01-01},
    abstract   = {OCTAVE LAROSE, University of Kent, UK SOPHIE KALEBA, University of Kent, UK HUMPHREY BURCHELL, University of Kent, UK STEFAN MARR, University of Kent, UK Thanks to partial evaluation and meta-tracing, it became practical to build language implementations that reach state-of-the-art peak performance by implementing only an interpreter. Systems such as RPython and GraalVM provide components such as a garbage collector and just-in-time compiler in a language-agnostic manner, greatly reducing implementation effort. However, meta-compilation-based language implementations still need to improve further to reach the low memory use and fast warmup behavior that custom-built systems provide. A key element in this endeavor is interpreter performance. Folklore tells us that bytecode interpreters are superior to abstract-syntax-tree (AST) interpreters both in terms of memory use and run-time performance. This work assesses the trade-offs between AST and bytecode interpreters to verify common assumptions and whether they hold in the context of meta-compilation systems. We implemented four interpreters, each an AST and a bytecode one using RPython and GraalVM. We keep the difference between the interpreters as small as feasible to be able to evaluate interpreter performance, peak performance, warmup, memory use, and the impact of individual optimizations. Our results show that both systems indeed reach performance close to Node.js/V8. Looking at interpreteronly performance, our AST interpreters are on par with, or even slightly faster than their bytecode counterparts. After just-in-time compilation, the results are roughly on par. This means bytecode interpreters do not have their widely assumed performance advantage. However, we can confirm that bytecodes are more compact in memory than ASTs, which becomes relevant for larger applications. However, for smaller applications, we noticed that bytecode interpreters allocate more memory because boxing avoidance is not as applicable, and because the bytecode interpreter structure requires memory, e.g., for a reified stack. Our results show AST interpreters to be competitive on top of meta-compilation systems. Together with possible engineering benefits, they should thus not be discounted so easily in favor of bytecode interpreters. CCS Concepts: {$\bullet$} Software and its engineering {$\rightarrow$} Interpreters; Just-in-time compilers.},
    langid     = {english},
    file       = {F:\Zotero\Data-storage\storage\NBU5WDQN\Larose 等 - 2023 - AST vs. Bytecode Interpreters in the Age of Meta-Compilation.pdf}
}
@inproceedings{lehmannEverythingOldNew,
    author    = {Daniel Lehmann and Johannes Kinder and Michael Pradel},
    title     = {Everything Old is New Again: Binary Security of {WebAssembly}},
    booktitle = {29th USENIX Security Symposium (USENIX Security 20)},
    year      = {2020},
    isbn      = {978-1-939133-17-5},
    pages     = {217--234},
    url       = {https://www.usenix.org/conference/usenixsecurity20/presentation/lehmann},
    publisher = {USENIX Association},
    month     = aug
}
@inproceedings{lehmannWasabiFrameworkDynamically2019,
    title      = {Wasabi: {{A Framework}} for {{Dynamically Analyzing WebAssembly}}},
    shorttitle = {Wasabi},
    booktitle  = {Proceedings of the {{Twenty-Fourth International Conference}} on {{Architectural Support}} for {{Programming Languages}} and {{Operating Systems}}},
    author     = {Lehmann, Daniel and Pradel, Michael},
    year       = {2019},
    month      = apr,
    pages      = {1045--1058},
    publisher  = {ACM},
    address    = {Providence RI USA},
    doi        = {10.1145/3297858.3304068},
    urldate    = {2024-11-28},
    isbn       = {978-1-4503-6240-5},
    langid     = {english},
    file       = {F:\Zotero\Data-storage\storage\CR5SISRJ\Lehmann和Pradel - 2019 - Wasabi A Framework for Dynamically Analyzing WebAssembly.pdf}
}

@misc{limSOKAnalysisWeb2021,
    title         = {{{SOK}}: {{On}} the {{Analysis}} of {{Web Browser Security}}},
    shorttitle    = {{{SOK}}},
    author        = {Lim, Jungwon and Jin, Yonghwi and Alharthi, Mansour and Zhang, Xiaokuan and Jung, Jinho and Gupta, Rajat and Li, Kuilin and Jang, Daehee and Kim, Taesoo},
    year          = {2021},
    month         = dec,
    number        = {arXiv:2112.15561},
    eprint        = {2112.15561},
    primaryclass  = {cs},
    publisher     = {arXiv},
    doi           = {10.48550/arXiv.2112.15561},
    urldate       = {2025-01-06},
    abstract      = {Web browsers are integral parts of everyone's daily life. They are commonly used for security-critical and privacy sensitive tasks, like banking transactions and checking medical records. Unfortunately, modern web browsers are too complex to be bug free (e.g., 25 million lines of code in Chrome), and their role as an interface to the cyberspace makes them an attractive target for attacks. Accordingly, web browsers naturally become an arena for demonstrating advanced exploitation techniques by attackers and state-of-the-art defenses by browser vendors. Web browsers, arguably, are the most exciting place to learn the latest security issues and techniques, but remain as a black art to most security researchers because of their fast-changing characteristics and complex code bases.},
    archiveprefix = {arXiv},
    langid        = {english},
    keywords      = {Computer Science - Cryptography and Security},
    file          = {F:\Zotero\Data-storage\storage\JKYV4CST\Lim 等 - 2021 - SOK On the Analysis of Web Browser Security.pdf}
}
@inproceedings{LinuxeBPFSubsys,
    title     = {Understanding the {{Security}} of {{Linux eBPF Subsystem}}},
    booktitle = {Proceedings of the 14th {{ACM SIGOPS Asia-Pacific Workshop}} on {{Systems}}},
    author    = {Mohamed, Mohamed Husain Noor and Wang, Xiaoguang and Ravindran, Binoy},
    year      = {2023},
    month     = aug,
    pages     = {87--92},
    publisher = {ACM},
    address   = {Seoul Republic of Korea},
    doi       = {10.1145/3609510.3609822},
    urldate   = {2024-12-03},
    abstract  = {Linux eBPF allows a userspace application to execute code inside the Linux kernel without modifying the kernel code or inserting a kernel module. An in-kernel eBPF verifier preverifies any untrusted eBPF bytecode before running it in kernel context. Currently, users trust the verifier to block malicious bytecode from being executed.},
    isbn      = {979-8-4007-0305-8},
    langid    = {english},
    keywords  = {ebpf},
    file      = {F:\Zotero\Data-storage\storage\2NG8WN86\Mohamed 等 - 2023 - Understanding the Security of Linux eBPF Subsystem.pdf}
}
@article{liuUnderstandingBugsPython2023,
    title   = {Towards Understanding Bugs in {{Python}} Interpreters},
    author  = {Liu, Di and Feng, Yang and Yan, Yanyan and Xu, Baowen},
    year    = {2023},
    month   = jan,
    journal = {Empirical Software Engineering},
    volume  = {28},
    number  = {1},
    pages   = {19},
    issn    = {1382-3256, 1573-7616},
    doi     = {10.1007/s10664-022-10239-x},
    urldate = {2025-01-03},
    langid  = {english}
}
@misc{LuaCVE-2020-3423,
    author       = {CVE},
    howpublished = {\url{https://www.cve.org/CVERecord?id=CVE-2020-3423}},
    title        = {A vulnerability in the implementation of the Lua interpreter},
    year         = {2020}
}

@misc{LuaCVE-2021-43519,
    author       = {CVE},
    howpublished = {\url{https://www.cve.org/CVERecord?id=CVE-2021-43519}},
    title        = {Stack overflow in Lua Interpreter 5.1.0~5.4.4},
    year         = {2021}
}
@misc{LuaCVE-2021-44964,
    author       = {CVE},
    howpublished = {\url{https://www.cve.org/CVERecord?id=CVE-2021-44964}},
    title        = {Use after free in garbage collector and finalizer of Lua interpreter {5.4.0~5.4.3}},
    year         = {2021}
}
@article{luoReverseEngineeringObfuscated2023,
    title     = {Reverse {{Engineering}} of {{Obfuscated Lua Bytecode}} via {{Interpreter Semantics Testing}}},
    author    = {Luo, Chenke and Ming, Jiang and Fu, Jianming and Peng, Guojun and Li, Zhetao},
    year      = {2023},
    journal   = {IEEE Transactions on Information Forensics and Security},
    volume    = {18},
    pages     = {3891--3905},
    issn      = {1556-6013, 1556-6021},
    doi       = {10.1109/TIFS.2023.3289254},
    urldate   = {2024-12-23},
    abstract  = {As an efficient and multi-platform scripting language, Lua is gaining increasing popularity in the industry. Unfortunately, Lua's unique advantages also catch cybercriminals' attention. A growing number of IoT malware authors switch to Lua for malicious payload development and then distribute malware in bytecode form. To impede malware code analysis, malware authors obfuscate standard Lua bytecode into a customized bytecode specification. Only the attached interpreter can execute that particular bytecode file. Rapid recovery of Lua obfuscated bytecode is essential for a swift response to new malware threats. However, existing generic code deobfuscation approaches cannot keep up with the pace of emerging threats. In this paper, we present a novel reverse engineering technique, called interpreter semantics testing. Given a customized interpreter used to execute obfuscated Lua bytecode, we construct a set of LuaGadgets that can adapt to the customized interpreter. Each LuaGadget contains a carefully chosen opcode sequence to fulfill an observable calculation---it is designed to test one or two particular opcodes at a time. Next, we mutate unknown opcode values to generate a bunch of test cases and run them using the customized interpreter; we can observe the expected result only when the mutation hits the opcode's right value. We perform test case prioritization to cost-effectively recover the semantics of all obfuscated opcodes. Our approach makes no assumptions about the interpreter's structure and is free from analyzing the numerous execution traces of opcode handlers. We have evaluated our tool, LuaHunt, with Lua malware variants and real-world applications. LuaHunt is able to recover the obfuscated bytecode's semantics within 90 seconds for each test case, and all of our deobfuscation results can pass the correctness testing. The encouraging results demonstrate that LuaHunt is a promising tool to lighten the burden of security analysts.},
    copyright = {https://ieeexplore.ieee.org/Xplorehelp/downloads/license-information/IEEE.html}
}
@misc{MozillaSpiderMonkey,
    author       = {Mozilla},
    howpublished = {\url{https://spidermonkey.dev/}},
    title        = {SpiderMonkey},
    year         = {2024}
}
@misc{niemetz2020bitwuzlasmtcomp2020,
    title         = {Bitwuzla at the SMT-COMP 2020},
    author        = {Aina Niemetz and Mathias Preiner},
    year          = {2020},
    eprint        = {2006.01621},
    archiveprefix = {arXiv},
    primaryclass  = {cs.LO},
    url           = {https://arxiv.org/abs/2006.01621}
}
@inproceedings{nodejsAbuse,
    author    = {Feng Xiao and Jianwei Huang and Yichang Xiong and Guangliang Yang and Hong Hu and Guofei Gu and Wenke Lee},
    title     = {Abusing Hidden Properties to Attack the Node.js Ecosystem},
    booktitle = {30th USENIX Security Symposium (USENIX Security 21)},
    year      = {2021},
    isbn      = {978-1-939133-24-3},
    pages     = {2951--2968},
    url       = {https://www.usenix.org/conference/usenixsecurity21/presentation/xiao},
    publisher = {USENIX Association},
    month     = aug
}
@phdthesis{OptPHPBytecode,
    type    = {Bachelor {{Thesis}}},
    title   = {Optimizing {{PHP Bytecode}} Using {{Type-Inferred SSA Form}}},
    author  = {Popov, Nikita},
    year    = {2016},
    address = {Berlin, Germany},
    langid  = {english},
    school  = {Technische Universit{\"a}t Berlin}
}

@misc{OracleHotspot,
    author       = {Oracle},
    howpublished = {\url{https://openjdk.org/}},
    title        = {Hotspot},
    year         = {2024}
}
@inproceedings{parkEmpiricalStudyPrioritizing2019,
    title     = {An {{Empirical Study}} of {{Prioritizing JavaScript Engine Crashes}} via {{Machine Learning}}},
    booktitle = {Proceedings of the 2019 {{ACM Asia Conference}} on {{Computer}} and {{Communications Security}}},
    author    = {Park, Sunnyeo and Kim, Dohyeok and Son, Sooel},
    year      = {2019},
    month     = jul,
    pages     = {646--657},
    publisher = {ACM},
    address   = {Auckland New Zealand},
    doi       = {10.1145/3321705.3329840},
    urldate   = {2025-01-02},
    abstract  = {The early discovery of security bugs in JavaScript (JS) engines is crucial for protecting Internet users from adversaries abusing zero-day vulnerabilities. Browser vendors, bug bounty hunters, and security researchers have been eager to find such security bugs by leveraging state-of-the-art fuzzers as well as their domain expertise. They report a bug when observing a crash after executing their JS test since a crash is an early indicator of a potential bug. However, it is difficult to identify whether such a crash indeed invokes security bugs in JS engines. Thus, unskilled bug reporters are unable to assess the security severity of their new bugs with JS engine crashes. Today, this classification of a reported security bug is completely manual, depending on the verdicts from JS engine vendors.},
    isbn      = {978-1-4503-6752-3},
    langid    = {english},
    file      = {F:\Zotero\Data-storage\storage\PAYRHV6R\Park 等 - 2019 - An Empirical Study of Prioritizing JavaScript Engine Crashes via Machine Learning.pdf}
}
@inproceedings{ProofofJITeBPFvmForIoT,
    title     = {End-to-End Mechanized Proof of a {{JIT-accelerated eBPF}} Virtual Machine for {{IoT}}},
    booktitle = {Computer Aided Verification},
    author    = {Yuan, Shenghao and Besson, Fr{\'e}d{\'e}ric and Talpin, Jean-Pierre},
    editor    = {Gurfinkel, Arie and Ganesh, Vijay},
    year      = {2024},
    pages     = {325--347},
    publisher = {Springer Nature Switzerland},
    address   = {Cham},
    doi       = {10.1007/978-3-031-65627-9_16},
    abstract  = {Modern operating systems have adopted Berkeley Packet Filters (BPF) as a mechanism to extend kernel functionalities dynamically, e.g., Linux's eBPF or RIOT's rBPF. The just-in-time (JIT) compilation of eBPF introduced in Linux eBPF for performance has however led to numerous critical issues. Instead, RIOT's rBPF uses a slower but memory-isolating interpreter (a virtual machine) which implements a defensive semantics of BPF; and therefore trades performance for security. To increase performance without sacrificing security, this paper presents a fully verified JIT implementation for RIOT's rBPF, consisting of: i/ an end-to-end refinement workflow to both proving the JIT correct from an abstract specification and by deriving a verified concrete C implementation; ii/ a symbolic CompCert interpreter for executing jited binary code; iii/ a verified JIT compiler for rBPF; iv/ a verified hybrid rBPF virtual machine. Our core contribution is, to the best of our knowledge, the first and fully verified rBPF JIT compiler with correctness guarantees from high-level specification to low-level implementation. Benchmarks on microcontrollers hosting the RIOT operating system demonstrate significant performance improvements over the existing implementations of rBPF, even in worst-case application scenarios.},
    isbn      = {978-3-031-65627-9},
    langid    = {english},
    file      = {F:\Zotero\Data-storage\storage\JUP2ZS28\Yuan 等 - 2024 - End-to-end mechanized proof of a JIT-accelerated eBPF virtual machine for IoT.pdf}
}
@inproceedings{ProvableSafeWASMSandbox,
    author    = {Jay Bosamiya and Wen Shih Lim and Bryan Parno},
    title     = {{Provably-Safe} Multilingual Software Sandboxing using {WebAssembly}},
    booktitle = {31st USENIX Security Symposium (USENIX Security 22)},
    year      = {2022},
    isbn      = {978-1-939133-31-1},
    address   = {Boston, MA},
    pages     = {1975--1992},
    url       = {https://www.usenix.org/conference/usenixsecurity22/presentation/bosamiya},
    publisher = {USENIX Association},
    month     = aug
}
@article{rayOverviewWebAssemblyIoT2023,
    title      = {An {{Overview}} of {{WebAssembly}} for {{IoT}}: {{Background}}, {{Tools}}, {{State-of-the-Art}}, {{Challenges}}, and {{Future Directions}}},
    shorttitle = {An {{Overview}} of {{WebAssembly}} for {{IoT}}},
    author     = {Ray, Partha Pratim},
    year       = {2023},
    month      = aug,
    journal    = {Future Internet},
    volume     = {15},
    number     = {8},
    pages      = {275},
    issn       = {1999-5903},
    doi        = {10.3390/fi15080275},
    urldate    = {2024-12-05},
    copyright  = {https://creativecommons.org/licenses/by/4.0/},
    langid     = {english},
    file       = {F:\Zotero\Data-storage\storage\DRC3DGQ9\Ray - 2023 - An Overview of WebAssembly for IoT Background, Tools, State-of-the-Art, Challenges, and Future Dire.pdf}
}
@book{riceLearningEBPFProgramming2023,
    title      = {Learning {{eBPF}}: Programming the {{Linux Kernel}} for Enhanced Observability, Networking, and Security},
    shorttitle = {Learning {{eBPF}}},
    author     = {Rice, Liz},
    year       = {2023},
    edition    = {First edition},
    publisher  = {O'Reilly Media},
    address    = {Sebastopol, CA},
    isbn       = {978-1-0981-3512-6},
    langid     = {english},
    lccn       = {005.3},
    keywords   = {Application software,Computer security,Development Automation,Linux,Open source software},
    annotation = {OCLC: on1353981026},
    file       = {F:\Zotero\Data-storage\storage\J9AXN9I3\Rice - 2023 - Learning eBPF programming the Linux Kernel for enhanced observability, networking, and security.pdf}
}
@inproceedings{romanoEmpiricalStudyBugs2021,
    title     = {An {{Empirical Study}} of {{Bugs}} in {{WebAssembly Compilers}}},
    booktitle = {2021 36th {{IEEE}}/{{ACM International Conference}} on {{Automated Software Engineering}} ({{ASE}})},
    author    = {Romano, Alan and Liu, Xinyue and Kwon, Yonghwi and Wang, Weihang},
    year      = {2021},
    month     = nov,
    pages     = {42--54},
    publisher = {IEEE},
    address   = {Melbourne, Australia},
    doi       = {10.1109/ASE51524.2021.9678776},
    urldate   = {2024-12-11},
    copyright = {https://ieeexplore.ieee.org/Xplorehelp/downloads/license-information/IEEE.html},
    isbn      = {978-1-6654-0337-5},
    langid    = {english},
    keywords  = {wasm},
    file      = {F:\Zotero\Data-storage\storage\GUNCQFFI\Romano 等 - 2021 - An Empirical Study of Bugs in WebAssembly Compilers.pdf}
}
@incollection{SecurityAnalysisOnPHP,
    title     = {Security {{Analysis}} of {{PHP Bytecode Protection Mechanisms}}},
    booktitle = {Research in {{Attacks}}, {{Intrusions}}, and {{Defenses}}},
    author    = {Wei{\ss}er, Dario and Dahse, Johannes and Holz, Thorsten},
    editor    = {Bos, Herbert and Monrose, Fabian and Blanc, Gregory},
    year      = {2015},
    volume    = {9404},
    pages     = {493--514},
    publisher = {Springer International Publishing},
    address   = {Cham},
    doi       = {10.1007/978-3-319-26362-5_23},
    urldate   = {2025-01-01},
    abstract  = {PHP is the most popular scripting language for web applications. Because no native solution to compile or protect PHP scripts exists, PHP applications are usually shipped as plain source code which is easily understood or copied by an adversary. In order to prevent such attacks, commercial products such as ionCube, Zend Guard, and Source Guardian promise a source code protection.},
    isbn      = {978-3-319-26361-8},
    langid    = {english},
    file      = {F:\Zotero\Data-storage\storage\ZQ39WW5C\Weißer 等 - 2015 - Security Analysis of PHP Bytecode Protection Mechanisms.pdf}
}
@inproceedings{SecurityBugsInembeddedInterpreter,
    title     = {Security Bugs in Embedded Interpreters},
    booktitle = {Proceedings of the 4th {{Asia-Pacific Workshop}} on {{Systems}}},
    author    = {Chen, Haogang and Cutler, Cody and Kim, Taesoo and Mao, Yandong and Wang, Xi and Zeldovich, Nickolai and Kaashoek, M. Frans},
    year      = {2013},
    month     = jul,
    pages     = {1--7},
    publisher = {ACM},
    address   = {Singapore Singapore},
    doi       = {10.1145/2500727.2500747},
    urldate   = {2024-12-26},
    abstract  = {Because embedded interpreters offer flexibility and performance, they are becoming more prevalent, and can be found at nearly every level of the software stack. As one example, the Linux kernel defines languages to describe packet filtering rules and uses embedded interpreters to filter packets at run time. As another example, the RAR archive format allows embedding bytecode in compressed files to describe reversible transformations for decompression. This paper presents an analysis of common pitfalls in embedded interpreter implementations, which can lead to security vulnerabilities, and their impact. We hope that these results are useful both in augmenting existing embedded interpreters and in aiding developers in building new, more secure embedded interpreters.},
    isbn      = {978-1-4503-2316-1},
    langid    = {english},
    file      = {F:\Zotero\Data-storage\storage\4G5KLU64\Chen 等 - 2013 - Security bugs in embedded interpreters.pdf}
}
@inproceedings{securityInPythonVM,
    title      = {On the {{Security}} of {{Python Virtual Machines}}: {{An Empirical Study}}},
    shorttitle = {On the {{Security}} of {{Python Virtual Machines}}},
    booktitle  = {2022 {{IEEE International Conference}} on {{Software Maintenance}} and {{Evolution}} ({{ICSME}})},
    author     = {Lin, Xinrong and Hua, Baojian and Fan, Qiliang},
    year       = {2022},
    month      = oct,
    pages      = {223--234},
    publisher  = {IEEE},
    address    = {Limassol, Cyprus},
    doi        = {10.1109/ICSME55016.2022.00028},
    urldate    = {2025-01-03},
    abstract   = {Python continues to be one of the most popular programming languages and has been used in many safetycritical fields such as medical treatment, autonomous driving systems, and data science. These fields put forward higher security requirements to Python ecosystems. However, existing studies on machine learning systems in Python concentrate on data security, model security and model privacy, and just assume the underlying Python virtual machines (PVMs) are secure and trustworthy. Unfortunately, whether such an assumption really holds is still unknown.},
    copyright  = {https://doi.org/10.15223/policy-029},
    isbn       = {978-1-6654-7956-1},
    langid     = {english},
    file       = {F:\Zotero\Data-storage\storage\V77H8DTF\Lin 等 - 2022 - On the Security of Python Virtual Machines An Empirical Study.pdf}
}
@phdthesis{SecurityLuaSandbox2022,
    type   = {Bachelor's Thesis},
    title  = {Security of the {{Lua Sandbox}}},
    author = {{Petr Ad{\'a}mek}},
    year   = {2022},
    langid = {english},
    school = {Czech Technical University in Prague}
}
@incollection{seitzerBytecodeInterpreterSecure2015,
    title     = {A {{Bytecode Interpreter}} for {{Secure Program Execution}} in {{Untrusted Main Memory}}},
    booktitle = {Computer {{Security}} -- {{ESORICS}} 2015},
    author    = {Seitzer, Maximilian and Gruhn, Michael and M{\"u}ller, Tilo},
    editor    = {Pernul, G{\"u}nther and Y A Ryan, Peter and Weippl, Edgar},
    year      = {2015},
    volume    = {9327},
    pages     = {376--395},
    publisher = {Springer International Publishing},
    address   = {Cham},
    doi       = {10.1007/978-3-319-24177-7_19},
    urldate   = {2025-01-04},
    abstract  = {Physical access to a system allows attackers to read out RAM through cold boot and DMA attacks. Thus far, counter measures protect only against attacks targeting disk encryption keys, while the remaining memory content is left vulnerable. We present a bytecode interpreter that protects code and data of programs against memory attacks by executing them without using RAM for sensitive content. Any program content within memory is encrypted, for which the interpreter utilizes TRESOR [1], a cold boot resistant implementation of the AES cipher. The interpreter was developed as a Linux kernel module, taking advantage of the CPU instruction sets AVX for additional registers, and AESNI for fast encryption. We show that the interpreter is secure against memory attacks, and that the overall performance is only a factor of 4 times slower than the performance of Python. Moreover, the performance penalty is mostly induced by the encryption.},
    isbn      = {978-3-319-24176-0},
    langid    = {english},
    file      = {F:\Zotero\Data-storage\storage\UTIALDRT\Seitzer 等 - 2015 - A Bytecode Interpreter for Secure Program Execution in Untrusted Main Memory.pdf}
}
@inproceedings{sonoyamaPerformanceStudyKotlin2021,
    title     = {Performance {{Study}} of {{Kotlin}} and {{Java Program Considering Bytecode Instructions}} and {{JVM JIT Compiler}}},
    booktitle = {2021 {{Ninth International Symposium}} on {{Computing}} and {{Networking Workshops}} ({{CANDARW}})},
    author    = {Sonoyama, Atsuya and Kamiyama, Takeshi and Oguchi, Masato and Yamaguchi, Saneyasu},
    year      = {2021},
    month     = nov,
    pages     = {127--133},
    publisher = {IEEE},
    address   = {Matsue, Japan},
    doi       = {10.1109/CANDARW53999.2021.00028},
    urldate   = {2025-01-04},
    abstract  = {Java has been widely used in the information technology field such as smartphones and server-side software. Java language and its runtime environments, which is called the Java ecosystem, have been developed and improved for some decades. This has become a huge and sophisticated ecosystem. Therefore, optimizing software codes, such as bytecodes program, should be well matched for this eco-system. Recently, a new programing language, which is called Kotlin, based on JVM (Java virtual machine) was developed. Kotlin is a well-designed program language, but is newly proposed and may not be exhaustively optimized for this Java ecosystem. In this paper, we discuss the performances of programs that are written in Java and Kotlin languages based on this ecosystem implementation. We first evaluate the performances of the loop function, which is a basic function of programming languages, of these two languages, then show that the performance of Kotlin is less than that of Java in the case of subjectively typical and common description way. Also, we show that even the performance of Java is less in some cases. We seconds discuss the reason for these performance declines comparing the bytecodes that are output from compilers of these languages. We reveal a small difference in bytecode sequences causes a large performance change due to the optimizer of JIT (Just-in-time) compiler implementation. We third discuss a method for improving the performance by solving this issue. One of the easiest ways is translating a JVM bytecode file. Finally, we evaluate our performance improving method and show that the method can improve the performance by 33\% in the largest case.},
    copyright = {https://ieeexplore.ieee.org/Xplorehelp/downloads/license-information/IEEE.html},
    isbn      = {978-1-6654-2835-4},
    langid    = {english},
    file      = {F:\Zotero\Data-storage\storage\J8RDX4L2\Sonoyama 等 - 2021 - Performance Study of Kotlin and Java Program Considering Bytecode Instructions and JVM JIT Compiler.pdf}
}
@inproceedings{Staicu2018SYNODEUA,
    title     = {{{SYNODE}}: {{Understanding}} and Automatically Preventing Injection Attacks on Node.Js},
    booktitle = {Network and Distributed System Security Symposium},
    author    = {Staicu, Cristian-Alexandru and Pradel, Michael and Livshits, Benjamin},
    year      = {2018},
    url       = {https://api.semanticscholar.org/CorpusID:51951699},
    doi       = {https://doi.org/10.14722/ndss.2018.23076}
}
@misc{staicuBilingualProblemsStudying2023,
    title         = {Bilingual {{Problems}}: {{Studying}} the {{Security Risks Incurred}} by {{Native Extensions}} in {{Scripting Languages}}},
    shorttitle    = {Bilingual {{Problems}}},
    author        = {Staicu, Cristian-Alexandru and Rahaman, Sazzadur and Kiss, {\'A}gnes and Backes, Michael},
    year          = {2023},
    month         = feb,
    number        = {arXiv:2111.11169},
    eprint        = {2111.11169},
    primaryclass  = {cs},
    publisher     = {arXiv},
    doi           = {10.48550/arXiv.2111.11169},
    urldate       = {2025-01-02},
    abstract      = {Scripting languages are continuously gaining popularity due to their ease of use and the flourishing software ecosystems that surround them. These languages offer crash and memory safety by design, thus, developers do not need to understand and prevent low-level security issues like the ones plaguing the C code. However, scripting languages often allow native extensions, which are a way for custom C/C++ code to be invoked directly from the high-level language. While this feature promises several benefits such as increased performance or the reuse of legacy code, it can also break the language's guarantees, e.g., crash-safety.},
    archiveprefix = {arXiv},
    langid        = {english},
    keywords      = {Computer Science - Cryptography and Security},
    file          = {F:\Zotero\Data-storage\storage\832REKA9\Staicu 等 - 2023 - Bilingual Problems Studying the Security Risks Incurred by Native Extensions in Scripting Languages.pdf}
}
@inproceedings{sunFindingCorrectnessBugs2024,
    title     = {Finding {{Correctness Bugs}} in {{eBPF Verifier}} with {{Structured}} and {{Sanitized Program}}},
    booktitle = {Proceedings of the {{Nineteenth European Conference}} on {{Computer Systems}}},
    author    = {Sun, Hao and Xu, Yiru and Liu, Jianzhong and Shen, Yuheng and Guan, Nan and Jiang, Yu},
    year      = {2024},
    month     = apr,
    pages     = {689--703},
    publisher = {ACM},
    address   = {Athens Greece},
    doi       = {10.1145/3627703.3629562},
    urldate   = {2024-11-26},
    langid    = {english},
    file      = {F:\Zotero\Data-storage\storage\4GZ37DE2\Sun 等 - 2024 - Finding Correctness Bugs in eBPF Verifier with Structured and Sanitized Program.pdf}
}
@article{SurveyOnVMP,
    author    = {李成扬 and 陈夏润 and  张汉 and 文伟平},
    title     = {虚拟机软件保护技术综述},
    publisher = {信息安全研究},
    year      = {2022},
    journal   = {信息安全研究},
    volume    = {8},
    number    = {7},
    eid       = {675},
    pages     = {675-},
    url       = http://www.sicris.cn/CN/abstract/article_1192.shtml
}
@misc{surveyOnWASMruntime,
    title         = {Research on {{WebAssembly Runtimes}}: {{A Survey}}},
    shorttitle    = {Research on {{WebAssembly Runtimes}}},
    author        = {{Yixuan Zhang} and {Mugeng Liu} and {Haoyu Wang} and {Yun Ma} and {Gang Huang} and {Xuanzhe Liu}},
    year          = {2024},
    month         = oct,
    number        = {arXiv:2404.12621},
    eprint        = {2404.12621},
    primaryclass  = {cs},
    publisher     = {arXiv},
    doi           = {10.48550/arXiv.2404.12621},
    urldate       = {2024-12-11},
    archiveprefix = {arXiv},
    langid        = {english},
    keywords      = {runtime,wasm},
    file          = {F:\Zotero\Data-storage\storage\UH93TJ8R\Zhang 等 - 2024 - Research on WebAssembly Runtimes A Survey.pdf}
}
@inproceedings{swivelHardenWASM,
    title     = {Swivel: {{Hardening WebAssembly}} against Spectre},
    booktitle = {30th {{USENIX}} Security Symposium ({{USENIX}} Security 21)},
    author    = {Narayan, Shravan and Disselkoen, Craig and Moghimi, Daniel and Cauligi, Sunjay and Johnson, Evan and Gang, Zhao and {Vahldiek-Oberwagner}, Anjo and Sahita, Ravi and Shacham, Hovav and Tullsen, Dean and Stefan, Deian},
    year      = {2021},
    month     = aug,
    pages     = {1433--1450},
    publisher = {USENIX Association},
    isbn      = {978-1-939133-24-3}
}

@misc{v8Engine,
    author       = {Google},
    howpublished = {\url{https://chromium.googlesource.com/v8/}},
    title        = {V8 javascript engine},
    year         = {2024}
}

@article{wang2022empirical,
    title     = {An Empirical Study on Bugs in Php},
    author    = {Wang, Ziyuan and Bu, Dexin and Xuan, Xingpeng and Gu, Jia},
    year      = {2022},
    journal   = {International Journal of Software Engineering and Knowledge Engineering},
    volume    = {32},
    number    = {06},
    pages     = {845--870},
    publisher = {World Scientific}
}
@article{wangPythonInterpreterBugs,
    title     = {An {{Empirical Study}} on {{Bugs}} in {{Python Interpreters}}},
    author    = {Wang, Ziyuan and Bu, Dexin and Sun, Aiyue and Gou, Shanyi and Wang, Yong and Chen, Lin},
    year      = {2022},
    month     = jun,
    journal   = {IEEE Transactions on Reliability},
    volume    = {71},
    number    = {2},
    pages     = {716--734},
    issn      = {0018-9529, 1558-1721},
    doi       = {10.1109/TR.2022.3159812},
    urldate   = {2024-12-23},
    copyright = {https://ieeexplore.ieee.org/Xplorehelp/downloads/license-information/IEEE.html},
    langid    = {english},
    file      = {F:\Zotero\Data-storage\storage\NB8MVGUE\Wang 等 - 2022 - An Empirical Study on Bugs in Python Interpreters.pdf}
}
@misc{waseemIssuesTheirCauses2024,
    title         = {Issues and {{Their Causes}} in {{WebAssembly Applications}}: {{An Empirical Study}}},
    shorttitle    = {Issues and {{Their Causes}} in {{WebAssembly Applications}}},
    author        = {Waseem, Muhammad and Das, Teerath and Ahmad, Aakash and Liang, Peng and Mikkonen, Tommi},
    year          = {2024},
    month         = apr,
    number        = {arXiv:2311.00646},
    eprint        = {2311.00646},
    publisher     = {arXiv},
    doi           = {10.48550/arXiv.2311.00646},
    url           = {http://doi.org/10.48550/arXiv.2311.00646},
    urldate       = {2024-11-28},
    archiveprefix = {arXiv},
    langid        = {english},
    keywords      = {Computer Science - Software Engineering}
}
@misc{wasmruntimeCVE-2023-48105,
    author       = {CVE},
    howpublished = {\url{https://www.cve.org/CVERecord?id=CVE-2023-48105}},
    title        = {{Heap Overflow Vulnerability in wasm-micro-runtime}},
    year         = {2023}
}
@misc{wasmruntimeCVE-2024-34250,
    author       = {CVE},
    howpublished = {\url{https://www.cve.org/CVERecord?id=CVE-2024-34250}},
    title        = {{Out-of-bound memory read vulnerability in wasm-micro-runtime}},
    year         = {2024}
}

@misc{wasmruntimeCVE-2024-34251,
    author       = {CVE},
    howpublished = {\url{https://www.cve.org/CVERecord?id=CVE-2024-34251}},
    title        = {{Heap buffer overflow vulnerability in wasm-micro-runtime}},
    year         = {2024}
}
@article{WebAssemblySummaryOnSecurity,
    title    = {{WebAssembly安全研究综述}},
    author   = {{庄骏杰} and {胡霜} and {华保健} and {汪炀} and {潘志中}},
    year     = {2024},
    journal  = {计算机研究与发展},
    volume   = {61},
    number   = {8},
    pages    = {1--27},
    issn     = {1000-1239},
    doi      = {10.7544/issn1000-1239.202330049},
    langid   = {chinese},
    keywords = {wasm},
    file     = {F:\Zotero\Data-storage\storage\CPVR4MS9\WebAssembly 安全研究综述.pdf}
}
@misc{WebKit,
    author       = {Apple},
    howpublished = {\url{https://webkit.org/}},
    title        = {WebKit},
    year         = {2024}
}
@inproceedings{yanUnderstandingPerformanceWebassembly2021,
    title     = {Understanding the Performance of Webassembly Applications},
    booktitle = {Proceedings of the 21st {{ACM Internet Measurement Conference}}},
    author    = {{Yutian Yan} and {Tengfei Tu} and {Lijian Zhao} and {Yuchen Zhou} and {Weihang Wang}},
    year      = {2021},
    month     = nov,
    pages     = {533--549},
    publisher = {ACM},
    address   = {Virtual Event},
    doi       = {10.1145/3487552.3487827},
    urldate   = {2024-12-12},
    isbn      = {978-1-4503-9129-0},
    langid    = {english},
    file      = {F:\Zotero\Data-storage\storage\69FWTM9N\Yan 等 - 2021 - Understanding the performance of webassembly applications.pdf}
}
@incollection{z3SMT,
    title      = {Z3: {{An Efficient SMT Solver}}},
    shorttitle = {Z3},
    booktitle  = {Tools and {{Algorithms}} for the {{Construction}} and {{Analysis}} of {{Systems}}},
    author     = {De Moura, Leonardo and Bj{\o}rner, Nikolaj},
    editor     = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard and Ramakrishnan, C. R. and Rehof, Jakob},
    year       = {2008},
    volume     = {4963},
    pages      = {337--340},
    publisher  = {Springer Berlin Heidelberg},
    address    = {Berlin, Heidelberg},
    doi        = {10.1007/978-3-540-78800-3_24},
    urldate    = {2025-01-09},
    isbn       = {978-3-540-78799-0},
    file       = {F:\Zotero\Data-storage\storage\DKW7TIEX\De Moura和Bjørner - 2008 - Z3 An Efficient SMT Solver.pdf}
}

@article{zhangCharacterizingDetectingWebAssembly2024,
    title   = {Characterizing and {{Detecting WebAssembly Runtime Bugs}}},
    author  = {{Yixuan Zhang} and {Shangtong Cao} and {Haoyu Wang} and {Zhenpeng Chen} and {Xiapu Luo} and {Dongliang Mu} and {Yun Ma} and {Gang Huang} and {Xuanzhe Liu}},
    year    = {2024},
    month   = feb,
    journal = {ACM Transactions on Software Engineering and Methodology},
    volume  = {33},
    number  = {2},
    pages   = {1--29},
    issn    = {1049-331X, 1557-7392},
    doi     = {10.1145/3624743},
    urldate = {2024-12-11},
    langid  = {english},
    file    = {F:\Zotero\Data-storage\storage\LTNPNC2B\Zhang 等 - 2024 - Characterizing and Detecting WebAssembly Runtime Bugs.pdf}
}
@article{zhangRegCPythonRegisterbasedPython2023,
    title      = {{{RegCPython}}: {{A Register-based Python Interpreter}} for {{Better Performance}}},
    shorttitle = {{{RegCPython}}},
    author     = {Zhang, Qiang and Xu, Lei and Xu, Baowen},
    year       = {2023},
    month      = mar,
    journal    = {ACM Transactions on Architecture and Code Optimization},
    volume     = {20},
    number     = {1},
    pages      = {1--25},
    issn       = {1544-3566, 1544-3973},
    doi        = {10.1145/3568973},
    urldate    = {2025-01-05},
    langid     = {english},
    file       = {F:\Zotero\Data-storage\storage\CM7KP43U\Zhang 等 - 2023 - RegCPython A Register-based Python Interpreter for Better Performance.pdf}
}
